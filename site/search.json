{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Home","text":"<p>This is a reference site that describes app development and deployment workflows, and provides information about the architecture and systems used by the Learning Technologies &amp; Services<sup>1</sup> group.</p> <ol> <li> <p>https://www.bcit.ca/learning-teaching-centre/ ↩</p> </li> </ol>","path":["Home"],"tags":[]},{"location":"deploying/","level":1,"title":"How to deploy apps","text":"<p>Content</p>","path":["Deploying","How to deploy apps"],"tags":[]},{"location":"deploying/creating-helm-charts/","level":1,"title":"Creating Helm Charts","text":"","path":["Deploying","Creating Helm Charts"],"tags":[]},{"location":"deploying/using-storage/","level":1,"title":"Using storage","text":"","path":["Deploying","Using storage"],"tags":[]},{"location":"developing/","level":1,"title":"Getting started with app development","text":"","path":["Developing","Getting started","Getting started with app development"],"tags":[]},{"location":"developing/#getting-started-with-app-development","level":1,"title":"Getting started with app development","text":"<p>Apps are developed to be deployed as containers on Kubernetes clusters, so by following consistent workflows, apps are easier to update and maintain.</p>","path":["Developing","Getting started","Getting started with app development"],"tags":[]},{"location":"developing/#requirements","level":2,"title":"Requirements","text":"<ul> <li>Docker<sup>1</sup></li> <li>A GitHub account<sup>2</sup></li> <li><code>git</code><sup>3</sup></li> </ul>","path":["Developing","Getting started","Getting started with app development"],"tags":[]},{"location":"developing/#starting-a-project","level":2,"title":"Starting a project","text":"<p>New projects typically start with:</p> <ol> <li>Creating a repository in github.com/bcit-lts<sup>4</sup></li> <li>Crafting a <code>README.md</code> that describes the project purpose</li> <li> <p>Adding a <code>Dockerfile</code> and a <code>docker-compose.yml</code> to the project root:</p> Dockerfiledocker-compose.yml Example Dockerfile<pre><code>#-- Build --#\nFROM node:24.6.0-alpine3.22 AS builder\n\nWORKDIR /app\n\nCOPY package.json ./\n\nRUN npm install\n\nCOPY . /app\n\nRUN npm run build\n\n#-- Clean --#\nFROM nginx:alpine AS cleaner\n\nWORKDIR /usr/share/nginx/html\n\nRUN rm -rf ./*\n\nCOPY --from=builder /app/dist ./\n\n#-- Release --#\nFROM nginxinc/nginx-unprivileged:alpine3.22-perl\n\nLABEL maintainer=courseproduction@bcit.ca\nLABEL org.opencontainers.image.source=\"https://github.com/bcit-ltc/course-workload-estimator\"\n\nWORKDIR /usr/share/nginx/html\n\nCOPY conf.d/default.conf /etc/nginx/conf.d/default.conf\nCOPY --from=cleaner /usr/share/nginx/html/ ./\n</code></pre> Example docker-compose.yml<pre><code>name: ${APP_NAME}\nservices:\n    app:\n        build:\n        context: .\n        target: builder\n\n        command: npm run start\n\n        environment:\n        - DEBUG=true\n\n        volumes:\n        - ./src:/app/src\n\n        ports:\n        - \"3000:3000\"\n</code></pre> </li> </ol> <p>Start local development with <code>docker compose up</code>.</p> <p>See the links in the side menu for more details.</p> <ol> <li> <p>https://docs.docker.com/get-started/ ↩</p> </li> <li> <p>https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github ↩</p> </li> <li> <p>https://git-scm.com/book/en/v2/Getting-Started-Installing-Git ↩</p> </li> <li> <p>https://github.com/bcit-lts ↩</p> </li> </ol>","path":["Developing","Getting started","Getting started with app development"],"tags":[]},{"location":"developing/codespace-development/","level":1,"title":"Codespace development","text":"<p>Instead of installing various command line tools and libraries locally, sometimes it is more convenient to login to a web-based dev environment that is pre-configured. <code>devcontainers</code><sup>1</sup> using GitHub Codespaces<sup>2</sup> are one such option.</p> <ol> <li> <p>https://containers.dev/ ↩</p> </li> <li> <p>https://github.com/features/codespaces ↩</p> </li> </ol>","path":["Developing","Getting started","Codespace development"],"tags":[]},{"location":"developing/git-workflow/","level":1,"title":"Git workflow","text":"<p>App development loosely follows GitHub Flow<sup>1</sup>, where features and fixes are committed to branches, and then merged to <code>main</code> through pull requests (PR).</p> <p></p> <p>Tip</p> <ul> <li>Commit often using short, descriptive comments.</li> <li>Keep branches short-lived - merge into <code>main</code> often</li> </ul> <ol> <li> <p>https://docs.github.com/en/get-started/using-github/github-flow ↩</p> </li> </ol>","path":["Developing","Getting started","Git workflow"],"tags":[]},{"location":"developing/local-dev/","level":1,"title":"Local development","text":"<p>Strategy</p> <p>Rather than building every functional component into one large monolith, build smaller apps that have one purpose and connect them together in a microservice architecture.</p> <p>Local development involves coding, building an image, running tests, and then committing changes to a branch.</p> <p></p> <p>A container-based \"dev loop\"</p> <p>We use Docker<sup>1</sup> to:</p> <ul> <li>run local dev environments using the <code>docker compose</code> command</li> <li>build development images</li> <li>run tests and other container commands</li> <li>scan images for vulnerabilities</li> </ul> <p>Docker makes it easy to develop containerized apps by providing a tool stack that builds and runs images on various platforms. Building a containerized app is pretty easy! Usually all you have to do is look for a good base image in Docker Hub<sup>2</sup> and configure a <code>Dockerfile</code> to copy your code into the image.</p>","path":["Developing","Getting started","Local development"],"tags":[]},{"location":"developing/local-dev/#the-dockerfile","level":2,"title":"The <code>Dockerfile</code>","text":"<p>The main configuration file for Docker images is the <code>Dockerfile</code>, a file that specifies how an app should be built. The <code>Dockerfile</code> is a sequence of commands that the build engine reads to create everything your app needs to run. The final output of the build is an <code>image</code> that can (generally) run on any machine.</p> Example Dockerfile<pre><code>#-- Build --#\nFROM node:24.6.0-alpine3.22 AS builder\n\nWORKDIR /app\n\nCOPY package.json ./\n\nRUN npm install\n\nCOPY . /app\n\nRUN npm run build\n...\n</code></pre> <p>For more information about options and best-practices about how to build a <code>Dockerfile</code>, see the <code>Dockerfile</code> reference documentation<sup>3</sup>.</p>","path":["Developing","Getting started","Local development"],"tags":[]},{"location":"developing/local-dev/#docker-composeyml","level":2,"title":"<code>docker-compose.yml</code>","text":"<p>When you install Docker, the package includes a command that creates a local dev environment to simulate how microservices can run together. The <code>docker compose</code> command reads the configuration specified in a <code>docker-compose.yml</code> file and then launches services based on that configuration.</p> <p>When developing locally, you can configure environment variables, secrets, volumes, networks, and other services inside a <code>docker-compose.yml</code>, alongside a framework runtime like a Python <code>runserver</code>, or a NodeJS dev server.</p> <p>Tip</p> <p>See Docker Compose – What is It, Example &amp; Tutorial<sup>4</sup> for a good overview of how <code>docker-compose.yml</code> files work.</p> <p>Example <code>docker-compose.yml</code></p> <pre><code># Use postgres/example for user/password credentials\nname: postgres\n\nservices:\n\n  db:\n    image: postgres\n    restart: always\n    environment:\n      POSTGRES_PASSWORD: example\n\n  adminer:\n    image: adminer\n    restart: always\n    ports:\n      - 8080:8080\n</code></pre> <ol> <li> <p>https://docs.docker.com/get-started/ ↩</p> </li> <li> <p>https://hub.docker.com/ ↩</p> </li> <li> <p>https://docs.docker.com/engine/reference/builder/ ↩</p> </li> <li> <p>https://spacelift.io/blog/docker-composes ↩</p> </li> </ol>","path":["Developing","Getting started","Local development"],"tags":[]},{"location":"developing/testing-deployment/","level":1,"title":"Testing deployment with Skaffold","text":"","path":["Developing","Getting started","Testing deployment with Skaffold"],"tags":[]},{"location":"infrastructure/","level":1,"title":"Infrastructure Systems &amp; Operations","text":"","path":["Infrastructure","Infrastructure Systems &amp; Operations"],"tags":[]},{"location":"infrastructure/connecting-workloads/","level":1,"title":"Connecting to Workloads","text":"","path":["Infrastructure","Traffic Routing & Load Balancing","Connecting to Workloads"],"tags":[]},{"location":"infrastructure/continuous-deployment/","level":1,"title":"GitOps with Flux","text":"","path":["Infrastructure","Continuous Deployment","GitOps with Flux"],"tags":[]},{"location":"infrastructure/creating-clusters/","level":1,"title":"Creating Kubernetes Clusters","text":"<p>RKE2 is the Kubernetes distribution.</p>","path":["Infrastructure","Virtual Machine Management","Creating Kubernetes Clusters"],"tags":[]},{"location":"infrastructure/github-source/","level":1,"title":"Managing Infrastructure","text":"","path":["Managing Infrastructure"],"tags":[]},{"location":"infrastructure/haproxy-lb/","level":1,"title":"Configuring HAProxy","text":"","path":["Infrastructure","Traffic Routing & Load Balancing","Configuring HAProxy"],"tags":[]},{"location":"infrastructure/installing-vault/","level":1,"title":"Hashicorp Vault Installation","text":"","path":["Infrastructure","Secrets Management","Hashicorp Vault Installation"],"tags":[]},{"location":"infrastructure/managing-clusters/","level":1,"title":"Managing Clusters","text":"","path":["Managing Clusters"],"tags":[]},{"location":"infrastructure/managing-vault/","level":1,"title":"Vault Management","text":"","path":["Infrastructure","Secrets Management","Vault Management"],"tags":[]},{"location":"infrastructure/preparing-vms/","level":1,"title":"Preparing Virtual Machines","text":"","path":["Infrastructure","Virtual Machine Management","Preparing Virtual Machines"],"tags":[]},{"location":"infrastructure/vault-secrets-operator/","level":1,"title":"Kubernetes Integration","text":"","path":["Infrastructure","Secrets Management","Kubernetes Integration"],"tags":[]},{"location":"monitoring/","level":1,"title":"Is the workload healthy?","text":"<p>Periodically verifying workload health and configuring alerts when there's a problem is important for service credibility.</p>","path":["Monitoring","Is the workload healthy?"],"tags":[]},{"location":"monitoring/alerting/","level":1,"title":"Alerts &amp; Notifications","text":"","path":["Monitoring","Alerts &amp; Notifications"],"tags":[]},{"location":"monitoring/logging/","level":1,"title":"Activity logging","text":"<p>Logs are captured, processed, and visualized by a Grafana stack.</p> <p>Most workloads have an <code>nginx-unprivileged</code> frontend that is configured with health endpoints that can be probed by Kubernetes probes and captured by Grafana:</p> <pre><code>...\n# Log all non-probe requests (browsers/APIs)\nmap $is_probe $not_probe { 0 1; 1 0; }\n\n# JSON access log for normal traffic\nlog_format json escape=json\n  '{'\n    '\"ts\":\"$time_iso8601\",'\n    '\"remote\":\"$remote_addr\",'\n    '\"method\":\"$request_method\",'\n    '\"uri\":\"$request_uri\",'\n    '\"status\":$status,'\n    '\"bytes\":$body_bytes_sent,'\n    '\"rt\":$request_time,'\n    '\"ref\":\"$http_referer\",'\n    '\"ua\":\"$http_user_agent\",'\n    '\"req_id\":\"$request_id\"'\n  '}';\n\n# Compact format for probe logs\nlog_format probe '$remote_addr - $time_local \"$request\" $status rt=$request_time';\n...\n# Health endpoints\n  location = /healthz {\n    access_log off;\n    add_header Content-Type application/json;\n    return 200 '{\"status\":\"HEALTHY\"}';\n  }\n\n  location = /healthz/startup {\n    access_log off;\n    add_header Content-Type application/json;\n    return 200 '{\"status\":\"STARTUP_OK\"}';\n  }\n\n  location = /healthz/ready {\n    access_log off;\n    add_header Content-Type application/json;\n    return 200 '{\"status\":\"READY_OK\"}';\n  }\n...\n</code></pre>","path":["Monitoring","Activity logging"],"tags":[]},{"location":"secret-management/","level":1,"title":"Getting started with app secrets","text":"","path":["Secrets","Getting started with app secrets"],"tags":[]},{"location":"secret-management/connecting-apps/","level":1,"title":"Connecting apps","text":"","path":["Secrets","Connecting apps"],"tags":[]},{"location":"secret-management/dynamic-credentials/","level":1,"title":"Dynamic credentials","text":"","path":["Secrets","Dynamic credentials"],"tags":[]},{"location":"secret-management/static-secrets/","level":1,"title":"Static secrets","text":"","path":["Secrets","Static secrets"],"tags":[]},{"location":"storage/","level":1,"title":"Getting started with app and state storage","text":"","path":["Storage","Getting started with app and state storage"],"tags":[]},{"location":"storage/app-storage/","level":1,"title":"Persistent storage for apps","text":"","path":["Storage","Persistent storage for apps"],"tags":[]},{"location":"storage/blob-storage/","level":1,"title":"Storage in Azure","text":"","path":["Storage","Storage in Azure"],"tags":[]}]}